# UV Packaging Transition Plan

## Architectural Goals
- Deliver the existing FastMCP server (`fast_mcp_server.py`) as a first-class `uv` package with stable module boundaries and reproducible installs.
- Consolidate all MCP-facing code (`mcp_tools`, `mcp_resources`, digest runtime) under the `chrome_update_digest` namespace to eliminate path hacks and ad-hoc imports.
- Provide clear entry points (CLI + MCP bootstrap) that survive packaging, CI, and future distribution to external operators.
- Maintain pipeline availability throughout the transition by sequencing refactors behind smoke tests and feature flags.

## Current State Snapshot
- Server entry point lives at the repository root and manually appends `src` to `sys.path`, while MCP tooling code is split across `src/mcp_tools`, `src/mcp_resources`, and `src/chrome_update_digest`.
- Dependency management relies on a `requirements.txt` + venv flow; there is no `pyproject.toml`, no canonical build backend, and no `uv` metadata.
- Documentation (e.g., `CLAUDE.md`) references script-based execution rather than `uv run` or packaged entry points.
- Tests cover pipeline behaviour but not the MCP server bootstrap path; smoke coverage for FastMCP is manual.

## Guiding Principles
- **Namespace first**: complete the package layout refactor before introducing `uv` manifests to avoid churn in published metadata.
- **Interfaces as contracts**: treat MCP tool/resource registration APIs as the public surface; keep them stable while refactoring internals.
- **Automation parity**: every manual step (local run, CI, deployment) must have a corresponding `uv` command once the migration is complete.
- **Progressive hardening**: add lightweight smoke tests and type hints in each phase to reduce regression risk as modules move.

## Phase 0: Baseline & Inventory
1. Catalogue all runtime entry points (CLI scripts, MCP server bootstrap, pipeline commands) and document expected invocation patterns in `project_docs/runbooks`.
2. Capture current dependency graph by exporting `pip freeze` for comparison once `pyproject.toml` is introduced; flag binary/runtime dependencies (e.g., `fastmcp` wheels).
3. Add a minimal FastMCP smoke test (pytest mark or script) that imports the server module and registers tools without launching the event loopâ€”this becomes the guardrail for later phases.
4. Annotate critical environment expectations (folder locations under `prompts/`, `upstream_docs/`, config files) so they can be expressed as package data or configuration options.

## Phase 1: Namespace Convergence
1. Create `src/chrome_update_digest/mcp/` and move `fast_mcp_server.py` into `server.py`, exposing `create_app()`/`main()` functions instead of relying on top-level script execution.
2. Relocate `src/mcp_tools` to `src/chrome_update_digest/mcp/tools` and `src/mcp_resources` to `src/chrome_update_digest/mcp/resources`; update imports to use absolute package paths and remove `sys.path.append`.
3. Promote shared runtime state (`DigestRuntimeRegistry`, configuration helpers) into `chrome_update_digest.mcp.runtime`, ensuring side-effect-free module initialization.
4. Introduce `__all__` exports or dataclasses where helpful so that FastMCP registration code reads cleanly and is easy to test.
5. Update the existing pipeline modules to import the MCP pieces via `chrome_update_digest.mcp.*` to keep the codebase consistent.
6. Extend unit tests to cover the new package layout (importability checks, registry wiring); run full pytest + pipeline smoke tests before merging.

## Phase 2: UV Project Scaffolding
1. Author `pyproject.toml` with:
   - `project` metadata (name `chrome-update-digest`, version placeholder, description, authors, python `>=3.11`).
   - Dependencies for pipeline + MCP server (`fastmcp`, `pyyaml`, `requests`, etc.).
   - Optional extras (`[project.optional-dependencies]`) for tooling like `pytest`, `mcp-cli`, or dev utilities.
   - `tool.uv` configuration: default resolver index, dev-dependencies, and script bindings.
   - Build backend (`hatchling` or `setuptools`); prefer hatchling for simple package builds.
2. Generate `uv.lock` (or allow `uv` to manage lock state) and update onboarding docs to use `uv sync` instead of ad-hoc venv setup.
3. Provide package data configuration (either via `tool.hatch.build.include` or MANIFEST settings) so prompts/resources ship inside the wheel and are accessible through `importlib.resources`.
4. Wire CLI entry points:
   - `chrome-update-digest-cli = chrome_update_digest.cli:main` for pipeline commands.
   - `chrome-update-digest-mcp = chrome_update_digest.mcp.server:main` for FastMCP bootstrap.
   - Declare them in `[project.scripts]`; add optional `[tool.uv.scripts]` aliases for common `uv run` shortcuts if desired.
5. Update docs to reference `uv run chrome-update-digest-mcp --args` and include examples of running within Claude MCP integrations.

## Phase 3: Integration & Delivery
1. Switch local and CI workflows to `uv run`:
   - `uv run pytest`
   - `uv run chrome-update-digest-cli digest ...`
   - `uv run chrome-update-digest-mcp --config config/mcp.yaml`
2. Ensure containerization or deployment scripts (if any) install via `uv pip install .` or use the built wheel; remove legacy `pip install -r requirements.txt` flows once parity is verified.
3. Publish internal beta artifact (wheel + lockfile) to Artifactory/pypi mirror or attach to release for validation by downstream consumers.
4. Document rollback strategy (reinstall from previous tag, restore `requirements.txt` flow) and keep it valid until UV rollout is signed off.

## Phase 4: Hardening & Observability
1. Add structured logging configuration inside `chrome_update_digest.mcp.server` so deployments share consistent log formats.
2. Introduce health-check endpoints or readiness probes if the MCP server will be hosted persistently.
3. Instrument key tool calls with tracing/metrics hooks (even simple counters) to aid future troubleshooting.
4. Gate major behaviours behind configuration (`pyproject` extras or env vars) to make future experimentation safer.

## Validation & Risk Mitigation
- Automate smoke runs in CI: `uv run python -c "import chrome_update_digest.mcp.server as s; s.create_app()"`.
- Maintain a short-lived feature branch per phase; keep migrations scripted (e.g., `uv sync`, renames) to ease rebase pain.
- Validate packaging by installing the built wheel into a clean virtual environment and running the MCP server end-to-end before declaring success.
- Keep `CLAUDE.md`, runbooks, and onboarding docs in lockstep with each milestone to prevent operational drift.

## Deliverables Checklist
- `pyproject.toml`, `uv.lock`, and updated README/CLAUDE docs.
- Refactored package layout with clean imports and no path mutations.
- Automated smoke test for MCP registration + pipeline regression tests.
- Published wheel (internal) and documented deployment procedure.
